<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>X Arena (IFrame)</title>
		<meta content="width=device-width, initial-scale=1.0" name="viewport">
		<meta content="yes" name="mobile-web-app-capable">
		<link rel="stylesheet" href="log.css">
		<script src="https://chrisacrobat.github.io/js-compilation/CreateWorkerFromRemoteURL.js"></script>
		<script>
			'use strict'
			let _arena;
			function a(){
				if(isIframe()){
					let data = JSON.parse(decodeURI(location.hash.substring(1)));
					if(data.arena !== undefined){
						let arenaURL = 'https://raw.githubusercontent.com/'+data.arena;
						let arenaArray = data.arena.split('/');
						arenaArray.pop();
						data.arena = arenaArray.join('/');
						_arena = data.arena;
						document.title = document.title.replace('X', data.arena);
						fetch(arenaURL+'/properties.json')
						.then(response => response.json())
						.then(json => {
							let limits = json.header.limits;
							if(limits.teams.min === undefined ? true : limits.teams.min <= data.participants.length
							&& limits.teams.max === undefined ? true : data.participants.length <= limits.teams.max
							&& limits.participants.min === undefined ? true : limits.participants.min <= data.participants.flat().length
							&& limits.participants.max === undefined ? true : data.participants.flat().length <= limits.participants.max
							&& limits.participantsPerTeam.min === undefined ? true : limits.participantsPerTeam.min <= data.participants.sort((x,y)=>y.length-x.length)[0].length
							&& limits.participantsPerTeam.max === undefined ? true : data.participants.sort((x,y)=>x.length-y.length)[0].length <= limits.participantsPerTeam.max){
								for(let index = 0; index < data.settings.general.averageOf; index++){
									let output = document.createElement('div');
									output.classList.add('log');
									document.body.appendChild(output);
									createWorkerFromRemoteURL(arenaURL+'/arena.js', true).then(arena => {
										arena.onmessage = messageEvent => {
											output.innerHTML += '<label for="message_'+JSON.stringify(messageEvent.data.message)+'" class="'+messageEvent.data.type+'">'+messageEvent.data.type+'</label><pre id="message_' + JSON.stringify(messageEvent.data.message) + '" class="' + messageEvent.data.type + '">' + JSON.stringify(messageEvent.data.message,null,'\t') + '</pre>';
											switch(messageEvent.data.type){
												case 'Ready-To-Start':
													if(!data.settings.general.allowRemoteExecution){
														blockNetwork();
													};
													arena.postMessage('Start');
													break;
												case 'Done':
													arena.terminate();
													break;
											}
										};
										arena.onerror = errorEvent => {
											console.log(errorEvent);
										};
										if(location.href.includes('?debug')){
											debugger;
										}
										arena.postMessage(data);
									});
								}
							}else{
								let message = 'Participants does not meet the arena limitations.';
								document.body.innerHTML += '<label for="message_limit_error" class="Error">Error</label><pre id="message_limit_error" class="Error">'+message+'</pre>';
								console.error(message);
							}
						});
					}else{
						output.innerHTML = 'No arena defined.';
					}
				}else{
					window.location.replace(window.location.href.replace('iframe.html', '')); // TODO: Fix.
				}
				function blockNetwork(){
					window.stop();
					window.requestAnimationFrame(blockNetwork);
				}
				function isIframe(){
					try{
						return window.self !== window.top;
					}catch(e){
						return true;
					}
				}
				window.onmessage = messageEvent => {
					messageEvent.source.postMessage({id: messageEvent.data, value: getOutput()}, messageEvent.origin);
				};
				function getOutput(){
					let output = {};
					output.arena = _arena;
					output.data = [];
					let outputList = document.getElementsByClassName('log');
					for(const outputKey in outputList){
						if(outputList.hasOwnProperty(outputKey)){
							let outputElement = outputList[outputKey];
							let segment = [];
							output.data.push(segment);
							let list = outputElement.getElementsByTagName('pre');
							for(const key in list){
								if(list.hasOwnProperty(key)){
									let element = list[key];
									segment.push({type: element.className, id: element.id, value: JSON.parse(element.innerHTML)});
								}
							}
						}
					}
					return output;
				}
			};
		</script>
	</head>
	<body onload="a()"></body>
</html>
